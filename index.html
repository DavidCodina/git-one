 <!DOCTYPE html>
<html>
<head>
    <title>GitHub Test</title>
    <link href="styles.css" rel="stylesheet" type="text/css">
</head>
    
<body>
	<div id="pseudo_body">
    
    <header>
        <div class="wrapper">
            <h1 id="logo">GitHub Test</h1>
            <nav>
                <ul>
                    <li><a href="">Home</a></li>
                    <li><a href="">About</a></li>
                    <li><a href="">Portfolio</a></li>
                    <li><a href="">Clients</a></li>
                    <li><a href="">Contact</a></li>
                </ul>
            </nav>
        </div>
    </header>
	
	<main>
		<section id="section_1"></section>
		<section id="section_2"></section>
		<section id="section_3"></section>
	</main>
    
</div>
</body>

</html>

<!-- ============================================================================================================================================================

============================================================================================================================================================= -->
<!-- Based on Tutorial 1: https://www.youtube.com/watch?v=3RjQznt-8kE&list=PL4cUxeGkcC9goXbgTDQ0n_4TBzOO0ocPR 



What is Git?
Git is a distributed version control system. That basically means that it's a system that records changes to our files over time.
We can recall specific versions of those files at any given time.
Many people can easily collaborate on a project an d have their own version of the project files on their computer.
Git allows you to store revisions in a project history in just one directory.
It allows us to rewind to any revision in project.
It allows us to work on new features without messing up the main codebase (i.e., branching)
It allows us to easily collaborate with other programmers.
		
		-Online service that host our projects
		-Share our code with other developers
		-Developers can download the projects and work on them.
		-They can re-upload their edits and merge them with the main codebase.
-->







<!-- Based on Tutorial 2: https://www.youtube.com/watch?v=MFtsLRphqDM&index=2&list=PL4cUxeGkcC9goXbgTDQ0n_4TBzOO0ocPR 

It goes over downloading git...
Next we open up the command line, and run git --version to double-check that we have it installed.
Next he goes over setting up a couple of optionss for Git: the username, and user email.
When we begin making changes in Git, it's going to want to know who is making those changes, so it can keep track of it.

	git config --global user.name DavidCodina
	git config --global user.email davidmcodina@hotmail.com


I did not actually do these things because it's already set up

	git config user.name		(returns: 	David Codina)
	git config user.email		(returnds: 	davidmcodina@hotmail.com)



Next he walks us through a few basic commands.

To change directories:

	cd .. 							takes us up a level (with space).
	cd David_Codina					takes us back into the David_Codina directory.
	ls								lists the contents of the current directory.
	mkdir test						Makes a new folder named test.
	touch index.html				Makes an index.html file within the current directory (touch doesn't work on windows.)
	Atom index.html					Opens the file in Atom
	open -a TextMate index.html		Opens the file in Textmate.
	rm index.html 					Deletes the file.
	rmdir							Deletes the test folder (assuming we're at that directory.)
-->







<!-- Based on Tutorial 3: https://www.youtube.com/watch?v=iNP_KmOFqXs&list=PL4cUxeGkcC9goXbgTDQ0n_4TBzOO0ocPR&index=3

In this tutorial we discuss how Git works.

What is a repo?
A repo (repository ) is a container for a project you want to track with Git (e.g., a website project)
We can have many different repos for many different projects on our computer.
A repository can be local (stored on your computer), or remote (stored within an online service -like Github)
Like a project folder which Git tracks the contents for us.
Each repo is tracked independently.

For example, we might have a project that looks like this:


myProject
		.git
		index.html
		styles.css
		images (folder)
			logo.png
			crazy_cat.png
		...


A surefire sign that this folder is a repository and being tracked is the .git file.
(I'm not sure, but this may be invisible on a mac. We may need to CMD + Shift + . to see it.)
Because .git is at the root level of the project, it means that Git will track changes to any file in this folder.
If for some reasong .git was in a subfolder, it would only track changes the extend from there.


What is a commit?
Commits are a bit like safe points in video games. Say we're building out our index.html file, and we
finish the header. This is a logical point in which to create a commit. So what we do is commit the state
of our code and files at that one particular time to the commit history. Down the line we might finish another
major section, and we make another commit. Let's say we make five different commits, then after commit 5 we say,
"Actually, I'd like to rewind and go back to how it was at the fourth commit." I want to go back to one of the 
save points. We can do that using Git because we have a commit history. We can roll back the code to any 
different commit in the commit history. It's tracking our different revisions of the code as we go along.
With Git working in this fashion, it would be very difficult to ever lose our progress.


Before we make an actual repository, let's talk about these three stages: Modified | Staging | Committed


We've got our project folder, and we make some changes to index.html. Those changes are now in the modified stage, whereby
the file has been changed but not committed. If we decide that we want to commit the files, then we can add the file to the
staging area. What that says to Git is, "When I make a commit, the changes I make to this index.html file... I want that to be
included in the commit."

For example, say we change both index.html, and style.css. We are now in the modified stage. Now we want to stage them, and
we do that (?), so that when we create a commit, those file changes are going to be committed, and a snapshot of those files is 
going to be added into the commit history. 

When we begin a repository in the most basic form, we have one branch, but it is possible to have mulitiple branches.
That will be discussed later. This allows us to work on new features without ever altering the code of the master branch.

We are now ready to create our very first repository
-->





<!-- Based on Tutorial 4: https://www.youtube.com/watch?v=v0Ch3yWQ-Zc&index=4&list=PL4cUxeGkcC9goXbgTDQ0n_4TBzOO0ocPR

In this tutorial we create our very first repository.
For this tutorial two directories were created:
				
							git-one
							git-two

We will create a repository in each of these directories in a minute...

To create a repository, we navigate to the git-one directory, then type:

	git init

This initializes an empty git repository.
If we were to then look at that folder manually, and type CMD + Shift + .   we would see the .git folder.
Now Git will track any changes we make to the project inside of that folder.

Note: the project folder doesn't have to be empty for us to create a repository.
We can create a repository which already has files in it. 

In the next tutorial we will edit files and add them to the staging area.
-->






<!-- Based on Tutorial 5: https://www.youtube.com/watch?v=KngvG8WzYLU&index=5&list=PL4cUxeGkcC9goXbgTDQ0n_4TBzOO0ocPR

In this tutorial, we discuss staging files.
In Atom green files indicate that they have been changed, but not committed.
That means that it's sitting in a 'modified zone'.
If we created a commit right now, it wouldn't actually committ anything.
What a commit does is take everythin from the staging area, and create a committ from that.
Currently, all we've done is modify a file. We've not added it to the staging area.

Here is a command to show which files are currently in the staging area, waiting to be committed.

		git status


It presently returns the following:

		On branch master

		Initial commit

		Untracked files:
	  		(use "git add <file>..." to include in what will be committed)

			.DS_Store
			index.html
			style.css

		nothing added to commit but untracked files present (use "git add" to track)

This shows us which files we have changed, and which files are in the staging area.

						In the Apple macOS operating system, .DS_Store is a file that stores c
						ustom attributes of its containing folder, 
						such as the position of icons or the choice of a background image


The three files are colored red to indicate that they have been changed, but are not yet staged.
If we want to stage them, all we need to do is say: git add ... (name of file.)

	git add index.html

So now after doing that if we type git status we get:


	On branch master

	Initial commit

	Changes to be committed:
  		(use "git rm --cached <file>..." to unstage)

		new file:   .DS_Store
		new file:   index.html

Now everything is in green.
So if we ran a git commit now, it would commit these files.


How do we unstage files?
Sometimes, we add files to the staging area that we don't necessarily mean to. This will remove it.

	git rm --cached index.html



Imagine we have a large project and we change 20 files.
To go through and type git add ... for every file can be tedious.
There's a shortcut. If we change a bunch of files, and want to add them all to the staging area we can type:

	git add .

So now if we do a commit, it will add all the files.





You might be thinking, "What on Earth is the point of having a staging area? Why don't we just commit straight away?"
The reason is that it's an extra blanket of security.
If we're making changes, we don't want to just commit them to hastily.
By adding them to this staging area, it allows us to review our changes before we do whut? .... commmit to them.
Committing is not something we should be doing all over the place.
We should only be doing it at very distinct points.

Another reason is that we can split our work up into separate commits.
Imagine that you are managing a website and there's two bugs on it.
We want to fix both bugs at the same time, so we change two files: one for each bug.
However, we might not want to bundle those changes together in the same commit.
What we can do is stage one of the files, and then commit that.
Then stage one of the other files and commit that.
This allows us to split our work up and make different commits for different changes.


In the next tutorial, we will look at actually making commits.
-->





<!-- Based on Tutorial 6: https://www.youtube.com/watch?v=Fhgga2s_RmM&list=PL4cUxeGkcC9goXbgTDQ0n_4TBzOO0ocPR&index=6

In this tutorial we look at making commits.

So far we've modified index.html, and styles.css, and we've staged them.
Now they're ready to be committed, they're ready be added to the commit history.
A commit is basically just like a save point.
In order to make a commit, we simply say:


	git commit -m "added index.html and styles.css"


-m indicates that we are passing a message. The message is in double quotes. It needs to be a descriptive message about what
the commit is. For example, if you were fixing a bug you might say "fixed bug in header", NOT "fixed a load of crap".
In other words, make sure that they are sufficiently descriptive because you will be using them for future reference.


After entering the above command, we get the following message back:


	[master (root-commit) ef2ea75] added index.html and styles.css
 		3 files changed, 488 insertions(+)
 		create mode 100644 .DS_Store
 		create mode 100644 index.html
 		create mode 100755 styles.css

We've made the commit on the master branch.
The id is ef2ea75
3 files have been changed, and there have been 488 insertions (insertions are the different lines of code).


Now for the purposes of this tutorial, we are going to make a couple of other commits, so that we can review the commit history.
In order to make the file visibly different, I will change the color of the h1 selector in the CSS to blue.
Now I add it to the staging area, check it, and then commit it.

	git add .
	git status
	git commit -m "changed the h1 heading to blue"

Command line output:

	[master a058bc4] changed the h1 heading to blue
	 2 files changed, 20 insertions(+)

Now let's change the heading to green, and commit again.

	git add .
	git commit -m "changed the h1 heading to green"

Command line output:

	[master a252a9d] changed the h1 heading to green
	 2 files changed, 13 insertions(+), 2 deletions(-)

Note: If we change a line, Git considers that line deleted, and re-added.


Just to really drive the point home, the tutorial does one more commit, so
in this instance I will change to h1 to red, and commit again.

	git add .
	git commit -m "changed the h1 heading to red"

Command line output:

	[master 15fb49f] changed the h1 heading to red
 	2 files changed, 16 insertions(+), 1 deletion(-)


So now we've made 3 commits, and we've got these 3 different snapshots in time on our master branch.
What do we do if we want to see this commit history?

	git log


Command line output:


	commit 15fb49f935c224af0fb65424ff4be66856dc82ca
	Author: David Codina <davidmcodina@hotmail.com>
	Date:   Sun Feb 25 12:28:54 2018 -0700

	    changed the h1 heading to red

	commit a252a9d651a985c6ba789f769b0653a45593aad7
	Author: David Codina <davidmcodina@hotmail.com>
	Date:   Sun Feb 25 12:24:54 2018 -0700

	    changed the h1 heading to green

	commit a058bc4367adbbfa7ffd125dec4f606e985fef34
	Author: David Codina <davidmcodina@hotmail.com>
	Date:   Sun Feb 25 12:22:28 2018 -0700

	    changed the h1 heading to blue

	commit ef2ea753351a38c84386433197395cb74d77d134
	Author: David Codina <davidmcodina@hotmail.com>
	Date:   Sun Feb 25 12:14:47 2018 -0700

	    added index.html and styles.css


Above we see four commits. The first commit shown is the most recent commit submitted.
Previously, after making a commit the comman line returned an id: [master 15fb49f]
That was actually the first few symbols. In the log output we actually get the full id: 15fb49f935c224af0fb65424ff4be66856dc82ca
Each log entry indicates whose made the commit, the email, and when the commit was made.
Additionally, we have the message we created indicating what was committed.
Cool.
However, if you've got 50 commits, it may be TMI, you might just want to see a condensed log output you can type:

	git log --oneline

Command line output:

	15fb49f changed the h1 heading to red
	a252a9d changed the h1 heading to green
	a058bc4 changed the h1 heading to blue
	ef2ea75 added index.html and styles.css

This reduces each commit down to a single line.


-->





<!-- Based on Tutorial 7: https://www.youtube.com/watch?v=RIYrfkZjWmA&index=7&list=PL4cUxeGkcC9goXbgTDQ0n_4TBzOO0ocPR

In this video we look at how to undo stuff for when it all goes wrong.
Up to this point we've made several commits to our master branch.
Now we want to look at how to undo things if you've made mistakes, or just if you want to...
We will look at three different methods: 

		checkout commit
		revert commit
		reset commit


They are listed in the order of danger. Checkout commit is not dangerous.
Revert commit is safe, but potentially not quite as safe.
Reset commit is unsafe. Be sure you need to use this before you do because it could potentially ruine your repo.


checkout commit:

	Say you want to see what the code was like a couple of commits earlier.
	We can use checkout commit.
	It will show us in our text editor the code at that point in time.
	However, any changes we make while checking out that commit will not be saved. It's read only.
	It will not allow us to alter or destroy the commit history in any way.

revert commit:

	This let's us undo a particular commit.
	It's almost like it deletes it from the commit chain.
	It doesn't actually delete it (as we'll see later.), but the result is the same: it's like it never existed.

reset commit:

	Permanently takes us back in time to a particular commmit.
	This implies that we will NEVER use the more recent commits.
	When you reset to a particular commit, it will permanently delete all commits that succeeded it.




We will look at examples of all three of these instances.
For the sake of this tutorial we will add two more commits.

	git add .
	git commit -m "changed the h1 heading to orange"
	
	
	
	git add .
	git commit -m "changed the h1 heading to purple"
	git log --oneline

Command line output:

	b255ad7 changed the h1 heading to purple
	32acd53 changed the h1 heading to orange
	15fb49f changed the h1 heading to red
	a252a9d changed the h1 heading to green
	a058bc4 changed the h1 heading to blue
	ef2ea75 added index.html and styles.css




Now let's start rewinding.
Presently the heading is purple. Let's say we wanted to just see what the code was like back at 32acd53
We can use checkout to do that. Note: It seems that it won't let us do this until everything is up to date, i.e., all current modifications have been staged and committed.

	git checkout 32acd53

Now to get back to the top of the stack, we type:

	git checkout master


Now for git revert. This will undo one particular commit. So, let's say we gave our heading font-family: "Comic Sans MS" in one commit, and a color of pink in the next commit. 


	8fdb224 made h1 pink
	bc7d994 Gave h1 Comic Sans MS
	462ba9e last commit before test
	...

What if we want to keep it pink but get rid of the 'Comic Sans MS'? We can do that using git revert.

	git revert bc7d994

That didn't work.

	error: could not revert bc7d994... Gave h1 Comic Sans MS
	hint: after resolving the conflicts, mark the corrected paths
	hint: with 'git add <paths>' or 'git rm <paths>'
	hint: and commit the result with 'git commit'

Probably becuase it was dealing witht the same element.
Let's try instead adding a paragraph, then removing the pink commit.

It started to get confusing so I erased the .git folder and started a new one. The log now looks like this:

		fce79ea made h1 blue from green
		d125cd4 added paragraph 2
		13e4d0b added paragraph 1
		ac3a900 added initial files

	

Okay, so now let's say we wanted to keep the blue h1, but remove the second paragraph. This should work because these two elements are
not conflicting. To revert the stage where there was no paragraph one we can simply type:

	git revert d125cd4



The command line output will then ask us to enter a commit message. 
If we don't, it seems that the changes will still be made, but there will be no record of it.
And this seems to mean that we can't undo our undo.
So... In the space provided I typed: "The second paragraph was removed"
Then I pressed ESC then Shift + :, then typed wq    and pressed enter.


The changes to be committed are the modification of index.html (this implies the paragraph removal).


Command line output:

			Revert "added paragraph 2"
  
			This reverts commit d125cd4c943ba1cd7a8ab99a8caea14642fcb2b1.

			# Please enter the commit message for your changes. Lines starting
			# with '#' will be ignored, and an empty message aborts the commit.
			# On branch master
			# Changes to be committed:
			#       modified:   index.html
			#
			"The second paragraph was removed"                                                                             
			~                                                                               
			~                                                                               
			~                                                                               
			~                                                                               
			~                                                                               
			~                                                                               
			~                                                                               
			~                                                                               
			~                                                                               
			~                                                                               
			~                                                                               
			~                                                                               
			"~/Desktop/GitHub/net ninja/git-one/.git/COMMIT_EDITMSG" 10L, 299C
			
			
			
Now if we type: git log --oneline we get:


		4938f19 Revert "added paragraph 2" This reverts commit d125cd4c943ba1cd7a8ab99a8caea14642fcb2b1.
		fce79ea made h1 blue from green
		d125cd4 added paragraph 2
		13e4d0b added paragraph 1
		ac3a900 added initial files

And if we refresh our browser, we should see that the test file has a blue h1, but the second paragraph has been removed.


=====================================================================================================================================

Now for git reset...
This can potentially destroy the contents of our repository. Let's say we want to go back in time to the point
where there were two paragraphs, but the h1 was still green. In other words, we want to ERASE all the stuff we've done
back to that point, and work from there again. We do this by saying git reset, and add the id of the commit that we
want to reset TO:

		git reset d125cd4

If we were to hit enter now, we would go back to that point, but also get a message indicating that we have some unstaged changes.

In other words, index.html and styles.css will still look the same as they did before,
but those changes would not have been committed.
If we typed git log --oneline, what we would see is:


		d125cd4 added paragraph 2
		13e4d0b added paragraph 1
		ac3a900 added initial files

From this point, we could re add individual files, or all of the files and commit them again.
This is useful for at least two reasons.
First let's say we wanted to rewind a project to where our styles.css was at a certain point, but suppose we don't actually want to rewind the index.html
We can simply recommit index.html, but not the styles.css.

Also, suppose we were happy with our progress, but we wanted to consolidate commits. We could reset the commit histor to a certain stage, then recommit all
of the files.


If you want to rewindin time and NOT PRESERVE THE CHANGES, then we can type:

		git reset d125cd4 --hard

And that's what I'm going to do now.


Command line output:

		HEAD is now at d125cd4 added paragraph 2


And if we type git log --oneline, we get:


		d125cd4 added paragraph 2
		13e4d0b added paragraph 1
		ac3a900 added initial files


And if we refresh the browser for index.html we get a page with a green h1 and two paragraphs.
All of the other commits are now permanently deleted!!!



In the next tutorial, we will look at the concept of branching.
-->


<!-- Based on Tutorial 8: https://www.youtube.com/watch?v=QV0kVNvkMxc&index=8&list=PL4cUxeGkcC9goXbgTDQ0n_4TBzOO0ocPR

 Branches are a major part of Git.
So far, we've only been working on one branch, and that is the master branch.
And we've been commiting only to the master branch.
Generally speaking, the master branch is going to represent the stable version of your code.
It's going to be the code that is released, or published.
For that reason, we don't really want to try out new code, or new features, on this master branch because it might mess the code up.
If we want to add a new feature to our application, what we really want to do is create an isolated environment to try this new feature.
And if we like it, and it works, we can merge this new feature into the master branch.
And that is what branching is all about.
So... Say that we have a new feature that we want to try out.
Instead of adding more commits onto the master branch, what we do is we make a new brach.
Which is an isolated environment to test this code out.
So to begin with we are copying the latest commit in our master branch as the first commit in our new branch.
Then we can work in that branch. Make commits to that branch. Test things out.
Then if we're happy with the new feature, and the new code, we can merge it back into the master branch.
That's called a merge commit.
Conversely, if everything goes wrong in this branch, or it doesn't work, we can simply delete that branch.

One of the cool things about branches is if we have two developers working on the same project at the same time
for two different new features, then one can make a branch to work on one feature.
The other can make a branch to work on another feature.
Then when each one is happy with their own respective code, they can individually merge back into the master branch.
This means that each member of a team can work on different features at the same time.

So... back in our project, it presently has 3 commits 

	d125cd4 added paragraph 2
	13e4d0b added paragraph 1
	ac3a900 added initial files


Now let's say we want to work on a new feature.
We're not going to begin working on the master branch becuase we might accidentally mess up the code.
Instead what we're going to do is create a new branch, so how do we do that?

	git branch test-section

Now if we want to see this branch we can type:

	git branch -a

This will show us all of the branches

  *	master
	test-section

The * means that we are currently on that branch.

If we want to be on the other branch, we need to checkout that branch:

	git checkout test-section

Now if we do git branch -a, we will see

  	master
  *	test-section


So now we can begin working on this new branch, new feature, new section, etc.
I created a new section and gave it min-height: 250px, border: 1px dashed red.
Then I added and committed it:


	git add .
	git commit -m "added a new section"


So now we have this file with a whole other section added to it, but it's isolated.
It's away from the master branch.
Thus if we typed:

		git checkout master


And refreshed the browser, we'd see our old version, without the experimental section.
And if we look at the actual code, the <section id="section_2"> is gone!
So... While we're on the master branch, we're not actually editing anything.


Now what if things go wrong, and we just want to delete that branch. 
First we go back to the master branch.

Now to deletet the test-section branch, we type:

	git branch -D test-section


-D for delete. Command line output:


	Deleted branch test-section (was 7c70e0c).

Note: git branch -d test-section  	will not work until we have actually merged the branch.
If we run that command now we will get the following error:

		error: The branch 'test-section' is not fully merged.
		If you are sure you want to delete it, run 'git branch -D test-section'.

==========================================================================================================================================

Now for working on two branches at the same time.

To create a branch we have been doing git branch branch_name, then we do git checkout branch_name.
However, there is a quicker way to do it all in one go.

git checkout -b branch_name

-b to imply that we are making  a new branch.


So... let's do

	git checkout -b feature-1


For feature-1 I added <section id="section_2"> with min-height: 200px; border: 1px dashed green;
Now we add and commit it.

Now let's go back to the master branch, and create a second branch:

	git checkout -b feature-2

Within this branch I created <section id="section_3"> with min-height: 200px; border: 1px dashed red;
And we add and commit it.

So now we've got two branches going on at the same time, and so far neither one of them has affected the master branch.

In the next tutorial, we will look at how to merge them back into the master branch.
-->




<!-- Based on Tutorial 9:  https://www.youtube.com/watch?v=XX-Kct0PfFc&index=9&list=PL4cUxeGkcC9goXbgTDQ0n_4TBzOO0ocPR

In this tutorial we look at how to merge branches, and also how to deal with conflicts.

To merge back into a branch, we have to be on the branch that we want to merge into.
In this case, we want to merge into the master branch, so we make sure we are on that branch

		git checkout master
		git branch -a

To merge a branch we simply say: git merge branch_name

	git merge feature-1


Command line output:

		Updating d125cd4..599b69d
		Fast-forward
		 index.html | 4 ++++
		 styles.css | 4 ++++
		 2 files changed, 8 insertions(+)

So now we have <section id="section_2"> as part of our master branch, and there is nothing to commmit.
If we do git log --oneline, we will see a new commit.
If we do git branch -a we will still see feature-1 as a distinct branch.
Fast forward just means that we are fast forwarding the master branch up to the code changes that we made in the feature-1 branch.

So now let's merge the other one.
		
		git merge feature-2

Infortunately, this produced a conflict. I think this was a conflict because it didn't know which section should be first because are
both children of <main>

		Auto-merging styles.css
		CONFLICT (content): Merge conflict in styles.css
		Auto-merging index.html
		CONFLICT (content): Merge conflict in index.html
		Automatic merge failed; fix conflicts and then commit the result.


I manually fixed the conflict and committed the result.
In the tutorial, he says you don't need to add a message when committing the results of a merge that initially had a conflict.
However, I think it's still a good idea to do that.
Otherwise, you'll just have to deal with that freaky screen with the ESC :wq stuff...
In any case, git branch -a still produces all three branches.
I'm assuming we can erase these branches when we feel comfortable.

==========================================================================================================================================

As we've seen sometimes things go to shit, and there is a conflict. That's what we will be looking at now. @3:42
I'm not following along with his example because I've already experienced my own conflicts.
However, when he says something noteworthy, I'll add that.

When you come across different conflicts, you should communicate with whoever has made the other changes and deciding between the two 
of you what the file should look like.



-->



<!-- Based on Tutorial 10: https://www.youtube.com/watch?v=fQLK8Ib_SKk&index=10&list=PL4cUxeGkcC9goXbgTDQ0n_4TBzOO0ocPR

In this video we are introduced to GitHub.
I did a git reset ac3a900, the recommitted the files to consolidate the log


-->




















